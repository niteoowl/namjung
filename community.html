<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>유니즈 베이스볼 시뮬레이터</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .card {
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08); /* Soft shadow */
            padding: 30px;
            margin-bottom: 20px;
        }
        .btn-primary {
            background-color: #4f46e5; /* Indigo */
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            transition: background-color 0.3s ease;
        }
        .btn-primary:hover {
            background-color: #4338ca; /* Darker indigo */
        }
        .btn-secondary {
            background-color: #e2e8f0; /* Light gray */
            color: #475569; /* Slate gray */
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            transition: background-color 0.3s ease;
        }
        .btn-secondary:hover {
            background-color: #cbd5e1; /* Darker light gray */
        }
        input[type="email"],
        input[type="password"],
        input[type="text"] {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            border: 1px solid #cbd5e1; /* Light gray border */
            border-radius: 8px;
            font-size: 16px;
        }
        .nav-link {
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .nav-link:hover {
            background-color: #e0e7ff; /* Light blue for hover */
        }
        .nav-link.active {
            background-color: #c7d2fe; /* Slightly darker blue for active */
            font-weight: 600;
            color: #3730a3; /* Darker indigo for active text */
        }
        .message-box {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #4CAF50; /* Green */
            color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            display: none; /* Hidden by default */
        }
        .message-box.error {
            background-color: #f44336; /* Red */
        }
        .message-box.info {
            background-color: #2196F3; /* Blue */
        }
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1001; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            width: 80%;
            max-width: 500px;
            text-align: center;
        }
        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        .close-button:hover,
        .close-button:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
        .loading-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            z-index: 9999;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        .spinner {
            border: 8px solid #f3f3f3;
            border-top: 8px solid #4f46e5;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100">
    <div id="messageBox" class="message-box"></div>
    <div id="loadingOverlay" class="loading-overlay">
        <div class="spinner"></div>
        <p class="mt-4 text-lg text-gray-700">로딩 중...</p>
    </div>

    <header class="bg-white shadow-md py-4">
        <div class="container flex justify-between items-center">
            <h1 class="text-2xl font-bold text-indigo-700">유니즈 베이스볼 시뮬레이터</h1>
            <nav id="mainNav" class="space-x-4">
                <button id="navLogin" class="nav-link active">로그인</button>
                <button id="navTeam" class="nav-link hidden">내 팀</button>
                <button id="navGame" class="nav-link hidden">경기</button>
                <button id="navStandings" class="nav-link hidden">순위표</button>
                <button id="navAdvanced" class="nav-link hidden">고급 기능</button>
                <button id="navLogout" class="nav-link hidden">로그아웃</button>
            </nav>
        </div>
    </header>

    <main class="container mt-8">
        <section id="authSection" class="card">
            <h2 class="text-3xl font-bold text-center mb-6 text-indigo-800">로그인 / 회원가입</h2>
            <div class="max-w-md mx-auto">
                <input type="email" id="authEmail" placeholder="이메일" class="block w-full p-3 mb-4 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500">
                <input type="password" id="authPassword" placeholder="비밀번호" class="block w-full p-3 mb-6 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500">
                <button id="loginBtn" class="btn-primary w-full mb-3">로그인</button>
                <button id="signupBtn" class="btn-secondary w-full">회원가입</button>
                <p id="authError" class="text-red-500 text-center mt-4"></p>
            </div>
        </section>

        <section id="teamSection" class="card hidden">
            <h2 class="text-3xl font-bold text-center mb-6 text-indigo-800">내 팀 관리</h2>
            <div id="teamCreation" class="max-w-md mx-auto">
                <h3 class="text-2xl font-semibold mb-4 text-center">팀 생성</h3>
                <input type="text" id="teamName" placeholder="팀 이름" class="block w-full p-3 mb-4 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500">
                <input type="text" id="teamHometown" placeholder="연고지" class="block w-full p-3 mb-6 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500">
                <button id="createTeamBtn" class="btn-primary w-full mb-3">팀 생성</button>
                <p id="teamCreationMessage" class="text-green-600 text-center mt-4"></p>
            </div>

            <div id="teamDetails" class="hidden mt-8">
                <h3 class="text-2xl font-semibold mb-4 text-center">현재 팀 정보</h3>
                <p class="text-lg mb-2"><span class="font-medium">팀명:</span> <span id="displayTeamName"></span></p>
                <p class="text-lg mb-2"><span class="font-medium">연고지:</span> <span id="displayTeamHometown"></span></p>
                <p class="text-lg mb-4"><span class="font-medium">팀 ID:</span> <span id="displayTeamId" class="text-sm text-gray-600"></span></p>
                <button id="generatePlayersBtn" class="btn-primary w-full mb-6">랜덤 선수 생성 (32명)</button>

                <h4 class="text-xl font-semibold mb-4 text-center">선수 목록</h4>
                <div id="playerList" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    </div>
            </div>
        </section>

        <section id="gameSection" class="card hidden">
            <h2 class="text-3xl font-bold text-center mb-6 text-indigo-800">경기 시뮬레이션</h2>
            <div id="lineupSetup" class="mb-8">
                <h3 class="text-2xl font-semibold mb-4 text-center">라인업 설정</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <label for="startingPitcherSelect" class="block text-lg font-medium text-gray-700 mb-2">선발 투수:</label>
                        <select id="startingPitcherSelect" class="w-full p-3 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500"></select>
                    </div>
                    <div>
                        <label for="batterLineupSelect" class="block text-lg font-medium text-gray-700 mb-2">타자 라인업 (9명 선택):</label>
                        <select id="batterLineupSelect" multiple class="w-full p-3 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500 h-48">
                            </select>
                        <p id="lineupError" class="text-red-500 text-sm mt-2"></p>
                    </div>
                </div>
                <button id="startGameBtn" class="btn-primary w-full mt-6">경기 시작</button>
            </div>

            <div id="gameDisplay" class="hidden">
                <h3 class="text-2xl font-semibold mb-4 text-center">경기 진행</h3>
                <div class="flex justify-around items-center mb-6 text-2xl font-bold">
                    <span id="gameTeamA"></span>
                    <span id="gameScoreA" class="text-indigo-700">0</span>
                    <span>-</span>
                    <span id="gameScoreB" class="text-indigo-700">0</span>
                    <span id="gameTeamB"></span>
                </div>
                <div id="gameLog" class="bg-gray-50 p-4 rounded-lg h-96 overflow-y-auto text-sm">
                    </div>
                <button id="nextInningBtn" class="btn-secondary w-full mt-4 hidden">다음 이닝</button>
            </div>
        </section>

        <section id="standingsSection" class="card hidden">
            <h2 class="text-3xl font-bold text-center mb-6 text-indigo-800">리그 순위표</h2>
            <table class="min-w-full bg-white rounded-lg shadow overflow-hidden">
                <thead>
                    <tr class="bg-indigo-600 text-white">
                        <th class="py-3 px-4 text-left">순위</th>
                        <th class="py-3 px-4 text-left">팀명</th>
                        <th class="py-3 px-4 text-left">승</th>
                        <th class="py-3 px-4 text-left">패</th>
                        <th class="py-3 px-4 text-left">승률</th>
                        <th class="py-3 px-4 text-left">게임차</th>
                    </tr>
                </thead>
                <tbody id="standingsTableBody">
                    </tbody>
            </table>
        </section>

        <section id="advancedSection" class="card hidden">
            <h2 class="text-3xl font-bold text-center mb-6 text-indigo-800">고급 기능</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div class="bg-gray-50 p-6 rounded-lg shadow-sm">
                    <h3 class="text-xl font-semibold mb-3">선수 성장 시스템</h3>
                    <p class="text-gray-700">선수들이 경기를 통해 능력치가 향상됩니다.</p>
                    <button class="btn-secondary mt-4">성장 확인 (미구현)</button>
                </div>
                <div class="bg-gray-50 p-6 rounded-lg shadow-sm">
                    <h3 class="text-xl font-semibold mb-3">자동 시즌 진행</h3>
                    <p class="text-gray-700 mb-2">현재 시즌: <span id="currentSeasonStatus">시즌 시작 전</span></p>
                    <p class="text-gray-700 mb-4">현재 일: <span id="currentSeasonDay">N/A</span></p>
                    <button id="toggleAutoSeasonBtn" class="btn-primary mt-4">자동 시즌 시작/중지</button>
                    <button id="startNewSeasonBtn" class="btn-secondary mt-4 hidden">새 시즌 시작</button>
                </div>
                <div class="bg-gray-50 p-6 rounded-lg shadow-sm">
                    <h3 class="text-xl font-semibold mb-3">트레이드 시스템</h3>
                    <p class="text-gray-700">다른 팀과 선수를 교환할 수 있습니다.</p>
                    <button class="btn-secondary mt-4">트레이드 (미구현)</button>
                </div>
                <div class="bg-gray-50 p-6 rounded-lg shadow-sm">
                    <h3 class="text-xl font-semibold mb-3">명예의 전당</h3>
                    <p class="text-gray-700">뛰어난 활약을 펼친 선수들이 헌액됩니다.</p>
                    <button class="btn-secondary mt-4">명예의 전당 (미구현)</button>
                </div>
                <div class="bg-gray-50 p-6 rounded-lg shadow-sm">
                    <h3 class="text-xl font-semibold mb-3">포인트 상점</h3>
                    <p class="text-gray-700">아이템을 구매하여 팀을 강화할 수 있습니다.</p>
                    <button class="btn-secondary mt-4">상점 방문 (미구현)</button>
                </div>
            </div>
        </section>
    </main>

    <div id="customModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <p id="modalMessage" class="text-lg mb-6"></p>
            <button id="modalConfirmBtn" class="btn-primary mr-2 hidden">확인</button>
            <button id="modalCancelBtn" class="btn-secondary hidden">취소</button>
            <button id="modalOkBtn" class="btn-primary">확인</button>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, onAuthStateChanged, signInWithCustomToken, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, query, where, addDoc, getDocs, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Firebase Configuration (provided by the environment)
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        let currentUser = null;
        let currentUserId = null;
        let userTeam = null;
        let userPlayers = [];
        let leagueTeams = []; // All teams in the league for standings and auto-games
        let leagueState = { currentDay: 0, seasonPhase: 'offseason', isSeasonActive: false }; // Global league state
        let autoSeasonInterval = null;

        const REGULAR_SEASON_DAYS = 70;
        const PLAYOFF_DAYS = 20;
        const TOTAL_SEASON_DAYS = REGULAR_SEASON_DAYS + PLAYOFF_DAYS;
        const MIN_TEAMS_FOR_LEAGUE = 10;

        // --- Utility Functions ---
        function showMessage(message, type = 'info') {
            const msgBox = document.getElementById('messageBox');
            msgBox.textContent = message;
            msgBox.className = `message-box ${type}`;
            msgBox.style.display = 'block';
            setTimeout(() => {
                msgBox.style.display = 'none';
            }, 3000);
        }

        function showModal(message, type = 'alert', onConfirm = null, onCancel = null) {
            const modal = document.getElementById('customModal');
            const modalMessage = document.getElementById('modalMessage');
            const modalConfirmBtn = document.getElementById('modalConfirmBtn');
            const modalCancelBtn = document.getElementById('modalCancelBtn');
            const modalOkBtn = document.getElementById('modalOkBtn');

            modalMessage.textContent = message;

            modalConfirmBtn.onclick = () => {
                modal.style.display = 'none';
                if (onConfirm) onConfirm();
            };
            modalCancelBtn.onclick = () => {
                modal.style.display = 'none';
                if (onCancel) onCancel();
            };
            modalOkBtn.onclick = () => {
                modal.style.display = 'none';
                if (onConfirm) onConfirm(); // For alert, OK acts as confirm
            };

            if (type === 'confirm') {
                modalConfirmBtn.classList.remove('hidden');
                modalCancelBtn.classList.remove('hidden');
                modalOkBtn.classList.add('hidden');
            } else { // 'alert'
                modalConfirmBtn.classList.add('hidden');
                modalCancelBtn.classList.add('hidden');
                modalOkBtn.classList.remove('hidden');
            }

            modal.style.display = 'flex';
        }

        document.querySelector('.close-button').onclick = () => {
            document.getElementById('customModal').style.display = 'none';
        };
        window.onclick = (event) => {
            if (event.target == document.getElementById('customModal')) {
                document.getElementById('customModal').style.display = 'none';
            }
        };

        function showLoading() {
            document.getElementById('loadingOverlay').style.display = 'flex';
        }

        function hideLoading() {
            document.getElementById('loadingOverlay').style.display = 'none';
        }

        function switchSection(sectionId) {
            const sections = ['authSection', 'teamSection', 'gameSection', 'standingsSection', 'advancedSection'];
            sections.forEach(id => {
                document.getElementById(id).classList.add('hidden');
            });
            document.getElementById(sectionId).classList.remove('hidden');

            const navLinks = document.querySelectorAll('.nav-link');
            navLinks.forEach(link => link.classList.remove('active'));
            document.getElementById(`nav${sectionId.replace('Section', '')}`).classList.add('active');
        }

        function updateNavVisibility(loggedIn) {
            document.getElementById('navLogin').classList.toggle('hidden', loggedIn);
            document.getElementById('navTeam').classList.toggle('hidden', !loggedIn);
            document.getElementById('navGame').classList.toggle('hidden', !loggedIn);
            document.getElementById('navStandings').classList.toggle('hidden', !loggedIn);
            document.getElementById('navAdvanced').classList.toggle('hidden', !loggedIn);
            document.getElementById('navLogout').classList.toggle('hidden', !loggedIn);

            if (!loggedIn) {
                switchSection('authSection');
            }
        }

        // --- Firebase Authentication ---
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUser = user;
                currentUserId = user.uid;
                console.log("사용자 로그인:", currentUser.email, "UID:", currentUserId);
                updateNavVisibility(true);
                await loadUserData();
                await loadLeagueTeams();
                await loadLeagueState(); // Load league state after teams
                switchSection('teamSection'); // Default to team section after login
            } else {
                currentUser = null;
                currentUserId = null;
                userTeam = null;
                userPlayers = [];
                console.log("사용자 로그아웃");
                updateNavVisibility(false);
                switchSection('authSection');
            }
            hideLoading();
        });

        // Initial sign-in with custom token if available
        async function initialSignIn() {
            showLoading();
            if (initialAuthToken) {
                try {
                    await signInWithCustomToken(auth, initialAuthToken);
                    console.log("Custom token sign-in successful.");
                } catch (error) {
                    console.error("Custom token sign-in failed:", error);
                    // Fallback to anonymous if custom token fails
                    try {
                        await signInAnonymously(auth);
                        console.log("Signed in anonymously as fallback.");
                    } catch (anonError) {
                        console.error("Anonymous sign-in failed:", anonError);
                        showMessage("로그인에 실패했습니다. 다시 시도해주세요.", 'error');
                    }
                }
            } else {
                try {
                    await signInAnonymously(auth);
                    console.log("Signed in anonymously (no custom token).");
                } catch (anonError) {
                    console.error("Anonymous sign-in failed:", anonError);
                    showMessage("로그인에 실패했습니다. 다시 시도해주세요.", 'error');
                }
            }
        }

        document.getElementById('signupBtn').addEventListener('click', async () => {
            const email = document.getElementById('authEmail').value;
            const password = document.getElementById('authPassword').value;
            document.getElementById('authError').textContent = '';
            showLoading();
            try {
                await createUserWithEmailAndPassword(auth, email, password);
                showMessage('회원가입 성공! 로그인되었습니다.', 'success');
            } catch (error) {
                console.error("회원가입 오류:", error);
                document.getElementById('authError').textContent = `회원가입 오류: ${error.message}`;
                showMessage('회원가입 실패.', 'error');
            } finally {
                hideLoading();
            }
        });

        document.getElementById('loginBtn').addEventListener('click', async () => {
            const email = document.getElementById('authEmail').value;
            const password = document.getElementById('authPassword').value;
            document.getElementById('authError').textContent = '';
            showLoading();
            try {
                await signInWithEmailAndPassword(auth, email, password);
                showMessage('로그인 성공!', 'success');
            } catch (error) {
                console.error("로그인 오류:", error);
                document.getElementById('authError').textContent = `로그인 오류: ${error.message}`;
                showMessage('로그인 실패.', 'error');
            } finally {
                hideLoading();
            }
        });

        document.getElementById('navLogout').addEventListener('click', async () => {
            showLoading();
            try {
                await signOut(auth);
                showMessage('로그아웃되었습니다.', 'info');
            } catch (error) {
                console.error("로그아웃 오류:", error);
                showMessage('로그아웃 실패.', 'error');
            } finally {
                hideLoading();
            }
        });

        // --- Navigation Handlers ---
        document.getElementById('navLogin').addEventListener('click', () => switchSection('authSection'));
        document.getElementById('navTeam').addEventListener('click', () => switchSection('teamSection'));
        document.getElementById('navGame').addEventListener('click', () => switchSection('gameSection'));
        document.getElementById('navStandings').addEventListener('click', () => switchSection('standingsSection'));
        document.getElementById('navAdvanced').addEventListener('click', () => switchSection('advancedSection'));

        // --- Data Loading and Display ---
        async function loadUserData() {
            if (!currentUserId) return;

            showLoading();
            try {
                // Listen for changes to the user's team data
                const teamDocRef = doc(db, `artifacts/${appId}/users/${currentUserId}/my_team`, currentUserId);
                onSnapshot(teamDocRef, (docSnap) => {
                    if (docSnap.exists()) {
                        userTeam = { id: docSnap.id, ...docSnap.data() };
                        console.log("내 팀 데이터 로드됨:", userTeam);
                        displayTeamDetails();
                        document.getElementById('teamCreation').classList.add('hidden');
                        document.getElementById('teamDetails').classList.remove('hidden');
                    } else {
                        userTeam = null;
                        console.log("내 팀 데이터 없음.");
                        document.getElementById('teamCreation').classList.remove('hidden');
                        document.getElementById('teamDetails').classList.add('hidden');
                    }
                    hideLoading();
                }, (error) => {
                    console.error("팀 데이터 스냅샷 오류:", error);
                    showMessage("팀 데이터를 불러오는 데 실패했습니다.", 'error');
                    hideLoading();
                });

                // Listen for changes to the user's players
                const playersCollectionRef = collection(db, `artifacts/${appId}/users/${currentUserId}/my_players`);
                onSnapshot(playersCollectionRef, (snapshot) => {
                    userPlayers = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    console.log("내 선수 데이터 로드됨:", userPlayers);
                    displayPlayerList();
                    populateLineupSelects();
                    hideLoading();
                }, (error) => {
                    console.error("선수 데이터 스냅샷 오류:", error);
                    showMessage("선수 데이터를 불러오는 데 실패했습니다.", 'error');
                    hideLoading();
                });

            } catch (error) {
                console.error("사용자 데이터 로드 오류:", error);
                showMessage("사용자 데이터를 불러오는 데 실패했습니다.", 'error');
                hideLoading();
            }
        }

        async function loadLeagueTeams() {
            showLoading();
            try {
                const teamsCollectionRef = collection(db, `artifacts/${appId}/public/data/teams`);
                onSnapshot(teamsCollectionRef, (snapshot) => {
                    leagueTeams = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    console.log("리그 팀 데이터 로드됨:", leagueTeams);
                    displayStandings();
                    updateSeasonStatusDisplay();
                    hideLoading();
                }, (error) => {
                    console.error("리그 팀 데이터 스냅샷 오류:", error);
                    showMessage("리그 팀 데이터를 불러오는 데 실패했습니다.", 'error');
                    hideLoading();
                });
            } catch (error) {
                console.error("리그 팀 로드 오류:", error);
                showMessage("리그 팀 데이터를 불러오는 데 실패했습니다.", 'error');
                hideLoading();
            }
        }

        async function loadLeagueState() {
            showLoading();
            try {
                const leagueStateDocRef = doc(db, `artifacts/${appId}/public/data/league_state`, 'current');
                onSnapshot(leagueStateDocRef, (docSnap) => {
                    if (docSnap.exists()) {
                        leagueState = docSnap.data();
                        console.log("리그 상태 로드됨:", leagueState);
                    } else {
                        // Initialize if not exists
                        leagueState = { currentDay: 0, seasonPhase: 'offseason', isSeasonActive: false };
                        setDoc(leagueStateDocRef, leagueState);
                        console.log("리그 상태 초기화됨.");
                    }
                    updateSeasonStatusDisplay();
                    updateAutoSeasonButton();
                    hideLoading();
                }, (error) => {
                    console.error("리그 상태 스냅샷 오류:", error);
                    showMessage("리그 상태를 불러오는 데 실패했습니다.", 'error');
                    hideLoading();
                });
            } catch (error) {
                console.error("리그 상태 로드 오류:", error);
                showMessage("리그 상태를 불러오는 데 실패했습니다.", 'error');
                hideLoading();
            }
        }

        function updateSeasonStatusDisplay() {
            document.getElementById('currentSeasonStatus').textContent = leagueState.seasonPhase === 'offseason' ? '시즌 시작 전' : (leagueState.seasonPhase === 'regular_season' ? '정규 시즌' : '플레이오프');
            document.getElementById('currentSeasonDay').textContent = leagueState.currentDay > 0 ? `${leagueState.currentDay}일차` : 'N/A';

            // Show "Start New Season" button if in offseason and enough teams
            if (leagueState.seasonPhase === 'offseason' && leagueTeams.length >= MIN_TEAMS_FOR_LEAGUE) {
                document.getElementById('startNewSeasonBtn').classList.remove('hidden');
            } else {
                document.getElementById('startNewSeasonBtn').classList.add('hidden');
            }
        }

        function updateAutoSeasonButton() {
            const toggleBtn = document.getElementById('toggleAutoSeasonBtn');
            if (leagueState.isSeasonActive) {
                toggleBtn.textContent = '자동 시즌 중지';
            } else {
                toggleBtn.textContent = '자동 시즌 시작';
            }
            if (leagueState.seasonPhase === 'offseason' && leagueTeams.length < MIN_TEAMS_FOR_LEAGUE) {
                toggleBtn.disabled = true;
                toggleBtn.classList.add('opacity-50', 'cursor-not-allowed');
                toggleBtn.textContent = `자동 시즌 시작 (${MIN_TEAMS_FOR_LEAGUE}팀 필요)`;
            } else {
                toggleBtn.disabled = false;
                toggleBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        }

        function displayTeamDetails() {
            if (userTeam) {
                document.getElementById('displayTeamName').textContent = userTeam.name;
                document.getElementById('displayTeamHometown').textContent = userTeam.hometown;
                document.getElementById('displayTeamId').textContent = userTeam.id;
            }
        }

        function displayPlayerList() {
            const playerListDiv = document.getElementById('playerList');
            playerListDiv.innerHTML = ''; // Clear previous list

            if (userPlayers.length === 0) {
                playerListDiv.innerHTML = '<p class="text-center text-gray-500 col-span-full">선수가 없습니다. "랜덤 선수 생성" 버튼을 클릭하세요.</p>';
                return;
            }

            // Sort players by position for better readability
            const sortedPlayers = [...userPlayers].sort((a, b) => {
                const positionOrder = {
                    '투수': 1, '포수': 2, '1루수': 3, '2루수': 4, '3루수': 5, '유격수': 6, '좌익수': 7, '중견수': 8, '우익수': 9
                };
                return (positionOrder[a.position] || 10) - (positionOrder[b.position] || 10);
            });

            sortedPlayers.forEach(player => {
                const playerCard = `
                    <div class="bg-blue-50 p-4 rounded-lg shadow-sm border border-blue-200">
                        <h5 class="text-lg font-semibold text-blue-800">${player.name}</h5>
                        <p class="text-sm text-gray-600 mb-2">${player.position}</p>
                        <ul class="text-sm">
                            <li>타율: ${player.battingAvg.toFixed(3)}</li>
                            <li>파워: ${player.power}</li>
                            <li>스피드: ${player.speed}</li>
                            <li>수비력: ${player.defense}</li>
                            <li>투구력: ${player.pitching || 'N/A'}</li>
                        </ul>
                    </div>
                `;
                playerListDiv.innerHTML += playerCard;
            });
        }

        function populateLineupSelects() {
            const pitcherSelect = document.getElementById('startingPitcherSelect');
            const batterSelect = document.getElementById('batterLineupSelect');
            pitcherSelect.innerHTML = '<option value="">선택하세요</option>';
            batterSelect.innerHTML = '';

            const pitchers = userPlayers.filter(p => p.position === '투수');
            const batters = userPlayers.filter(p => p.position !== '투수');

            pitchers.forEach(p => {
                const option = document.createElement('option');
                option.value = p.id;
                option.textContent = `${p.name} (투수, 투구력: ${p.pitching})`;
                pitcherSelect.appendChild(option);
            });

            batters.forEach(p => {
                const option = document.createElement('option');
                option.value = p.id;
                option.textContent = `${p.name} (${p.position}, 타율: ${p.battingAvg.toFixed(3)})`;
                batterSelect.appendChild(option);
            });
        }

        function displayStandings() {
            const standingsTableBody = document.getElementById('standingsTableBody');
            standingsTableBody.innerHTML = '';

            if (leagueTeams.length === 0) {
                standingsTableBody.innerHTML = '<tr><td colspan="6" class="py-4 text-center text-gray-500">리그 팀 데이터가 없습니다.</td></tr>';
                return;
            }

            // Sort teams by winning percentage (descending)
            const sortedTeams = [...leagueTeams].sort((a, b) => {
                const winPctA = a.wins / (a.wins + a.losses) || 0;
                const winPctB = b.wins / (b.wins + b.losses) || 0;
                return winPctB - winPctA;
            });

            let rank = 1;
            let firstPlaceWins = sortedTeams[0] ? sortedTeams[0].wins : 0;
            let firstPlaceLosses = sortedTeams[0] ? sortedTeams[0].losses : 0;

            sortedTeams.forEach((team, index) => {
                const winPct = (team.wins + team.losses) === 0 ? '0.000' : (team.wins / (team.wins + team.losses)).toFixed(3);
                let gamesBehind = '-';
                if (index > 0) {
                    const gb = ((firstPlaceWins - team.wins) + (team.losses - firstPlaceLosses)) / 2;
                    gamesBehind = gb.toFixed(1);
                }

                const row = `
                    <tr class="${index % 2 === 0 ? 'bg-gray-50' : 'bg-white'} border-b border-gray-200">
                        <td class="py-3 px-4">${rank++}</td>
                        <td class="py-3 px-4">${team.name} (${team.hometown})</td>
                        <td class="py-3 px-4">${team.wins}</td>
                        <td class="py-3 px-4">${team.losses}</td>
                        <td class="py-3 px-4">${winPct}</td>
                        <td class="py-3 px-4">${gamesBehind}</td>
                    </tr>
                `;
                standingsTableBody.innerHTML += row;
            });
        }


        // --- Team Management Functions ---
        document.getElementById('createTeamBtn').addEventListener('click', async () => {
            const teamName = document.getElementById('teamName').value.trim();
            const teamHometown = document.getElementById('teamHometown').value.trim();
            if (!teamName || !teamHometown) {
                showMessage('팀 이름과 연고지를 입력해주세요.', 'error');
                return;
            }
            if (!currentUserId) {
                showMessage('로그인 후 팀을 생성할 수 있습니다.', 'error');
                return;
            }

            showLoading();
            try {
                // Check if user already has a team
                const userTeamDocRef = doc(db, `artifacts/${appId}/users/${currentUserId}/my_team`, currentUserId);
                const userTeamSnap = await getDoc(userTeamDocRef);
                if (userTeamSnap.exists()) {
                    showMessage('이미 팀을 가지고 계십니다.', 'error');
                    hideLoading();
                    return;
                }

                const newTeamData = {
                    name: teamName,
                    hometown: teamHometown,
                    ownerId: currentUserId,
                    wins: 0,
                    losses: 0,
                    createdAt: new Date().toISOString() // Store as ISO string
                };

                // Add to private collection
                await setDoc(userTeamDocRef, newTeamData);

                // Add to public collection (using currentUserId as teamId for simplicity)
                const publicTeamDocRef = doc(db, `artifacts/${appId}/public/data/teams`, currentUserId);
                await setDoc(publicTeamDocRef, newTeamData);

                showMessage('팀이 성공적으로 생성되었습니다!', 'success');
                document.getElementById('teamName').value = '';
                document.getElementById('teamHometown').value = '';
            } catch (error) {
                console.error("팀 생성 오류:", error);
                showMessage(`팀 생성 실패: ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        });

        const koreanSurnames = ["김", "이", "박", "최", "정", "강", "조", "윤", "장", "임", "한", "오", "서", "신", "권", "황", "안", "송", "류", "전", "홍", "고", "문", "양", "손", "배", "백", "허", "유", "남", "심", "노", "하", "곽", "성", "차", "주", "구", "우", "신", "임", "전", "민", "유", "진", "변", "채", "천", "방", "공", "현", "함", "염", "양", "변", "여", "추", "나", "원", "엄", "봉", "좌", "맹", "탁", "제", "팽", "육", "진", "예", "연", "위", "명", "범", "좌", "간", "소", "길", "경", "사", "석", "선", "설", "소", "성", "수", "순", "시", "신", "심", "안", "양", "어", "여", "연", "염", "예", "오", "옥", "온", "왕", "용", "우", "원", "위", "유", "육", "윤", "이", "인", "임", "장", "재", "전", "정", "제", "조", "주", "지", "진", "차", "채", "창", "천", "최", "추", "탁", "팽", "편", "표", "하", "한", "함", "허", "현", "형", "호", "홍", "황"];
        const koreanGivenNames = ["민준", "서준", "도윤", "시우", "하준", "지호", "준서", "현우", "건우", "우진", "예준", "유준", "서아", "하윤", "서윤", "지유", "하은", "수아", "지아", "다은", "예나", "채원", "윤서", "지우", "민서", "서연", "하린", "아린", "나윤", "서현", "지현", "민지", "수민", "예린", "유진", "채윤", "은서", "소율", "가은", "아윤", "다윤", "서영", "소영", "지민", "지원", "하율", "혜원", "효주", "희원"];
        const positions = ['투수', '포수', '1루수', '2루수', '3루수', '유격수', '좌익수', '중견수', '우익수'];

        function generateRandomPlayerName() {
            const surname = koreanSurnames[Math.floor(Math.random() * koreanSurnames.length)];
            const givenName = koreanGivenNames[Math.floor(Math.random() * koreanGivenNames.length)];
            return `${surname}${givenName}`;
        }

        function generateRandomStats(position) {
            const stats = {
                battingAvg: parseFloat((Math.random() * 0.2 + 0.2).toFixed(3)), // 0.200 - 0.400
                power: Math.floor(Math.random() * 60) + 40, // 40-100
                speed: Math.floor(Math.random() * 60) + 40, // 40-100
                defense: Math.floor(Math.random() * 60) + 40, // 40-100
                pitching: 0 // Default for non-pitchers
            };
            if (position === '투수') {
                stats.pitching = Math.floor(Math.random() * 60) + 40; // 40-100
                stats.battingAvg = parseFloat((Math.random() * 0.1 + 0.1).toFixed(3)); // Pitchers have lower batting
                stats.power = Math.floor(Math.random() * 30) + 20;
            }
            return stats;
        }

        document.getElementById('generatePlayersBtn').addEventListener('click', async () => {
            if (!userTeam) {
                showMessage('먼저 팀을 생성해주세요.', 'error');
                return;
            }
            if (userPlayers.length > 0) {
                showModal('이미 선수가 존재합니다. 다시 생성하면 기존 선수들이 모두 삭제됩니다. 계속하시겠습니까?', 'confirm', async () => {
                    await generateAndSavePlayers();
                });
            } else {
                await generateAndSavePlayers();
            }
        });

        async function generateAndSavePlayers() {
            showLoading();
            try {
                const playersCollectionRef = collection(db, `artifacts/${appId}/users/${currentUserId}/my_players`);

                // Delete existing players first
                const existingPlayers = await getDocs(playersCollectionRef);
                const deletePromises = existingPlayers.docs.map(docSnap => deleteDoc(doc(db, `artifacts/${appId}/users/${currentUserId}/my_players`, docSnap.id)));
                await Promise.all(deletePromises);

                const finalPlayers = [];
                const positionCounts = {
                    '투수': 0, '포수': 0, '1루수': 0, '2루수': 0, '3루수': 0, '유격수': 0, '좌익수': 0, '중견수': 0, '우익수': 0
                };
                const minPlayersPerPosition = {
                    '투수': 5, '포수': 2, '1루수': 2, '2루수': 2, '3루수': 2, '유격수': 2, '좌익수': 2, '중견수': 2, '우익수': 2
                };

                // Ensure minimum players per position
                for (const pos of positions) {
                    for (let i = 0; i < minPlayersPerPosition[pos]; i++) {
                        finalPlayers.push({
                            name: generateRandomPlayerName(),
                            position: pos,
                            ...generateRandomStats(pos)
                        });
                        positionCounts[pos]++;
                    }
                }

                // Fill remaining slots up to 32 players
                while (finalPlayers.length < 32) {
                    const randomPosition = positions[Math.floor(Math.random() * positions.length)];
                    // Simple cap to avoid too many of one position
                    if (positionCounts[randomPosition] < (randomPosition === '투수' ? 8 : 5)) {
                        finalPlayers.push({
                            name: generateRandomPlayerName(),
                            position: randomPosition,
                            ...generateRandomStats(randomPosition)
                        });
                        positionCounts[randomPosition]++;
                    }
                }

                const addPromises = finalPlayers.map(player => addDoc(playersCollectionRef, player));
                await Promise.all(addPromises);

                showMessage(`${finalPlayers.length}명의 선수가 성공적으로 생성되었습니다!`, 'success');
            } catch (error) {
                console.error("선수 생성 오류:", error);
                showMessage(`선수 생성 실패: ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }

        // --- Game Simulation Functions ---
        document.getElementById('startGameBtn').addEventListener('click', async () => {
            if (!userTeam || userPlayers.length === 0) {
                showMessage('팀을 생성하고 선수를 먼저 생성해주세요.', 'error');
                return;
            }
            if (leagueState.isSeasonActive) {
                showMessage('시즌이 진행 중입니다. 수동 경기는 시즌 종료 후 가능합니다.', 'info');
                return;
            }

            const pitcherId = document.getElementById('startingPitcherSelect').value;
            const batterIds = Array.from(document.getElementById('batterLineupSelect').selectedOptions).map(option => option.value);

            if (!pitcherId) {
                document.getElementById('lineupError').textContent = '선발 투수를 선택해주세요.';
                return;
            }
            if (batterIds.length !== 9) {
                document.getElementById('lineupError').textContent = '타자 라인업 9명을 선택해주세요.';
                return;
            }

            document.getElementById('lineupError').textContent = '';

            const startingPitcher = userPlayers.find(p => p.id === pitcherId);
            const batterLineup = batterIds.map(id => userPlayers.find(p => p.id === id));

            if (!startingPitcher || batterLineup.some(p => !p)) {
                showMessage('선택된 선수 정보를 찾을 수 없습니다. 새로고침 후 다시 시도해주세요.', 'error');
                return;
            }

            // Select a random opponent team from leagueTeams (excluding current user's team)
            const opponentTeams = leagueTeams.filter(team => team.id !== currentUserId);
            if (opponentTeams.length === 0) {
                showMessage('경기를 진행할 상대 팀이 없습니다. 다른 사용자가 팀을 생성할 때까지 기다려주세요.', 'info');
                return;
            }
            const opponentTeam = opponentTeams[Math.floor(Math.random() * opponentTeams.length)];

            // Fetch opponent players for manual game
            showLoading();
            let opponentPlayers = [];
            try {
                const oppPlayersCollectionRef = collection(db, `artifacts/${appId}/users/${opponentTeam.ownerId}/my_players`);
                const oppPlayersSnapshot = await getDocs(oppPlayersCollectionRef);
                opponentPlayers = oppPlayersSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                if (opponentPlayers.length < 9) { // Need at least 9 players for a lineup
                    showMessage(`상대 팀 (${opponentTeam.name})의 선수 데이터가 부족합니다.`, 'error');
                    hideLoading();
                    return;
                }
            } catch (error) {
                console.error("상대 팀 선수 로드 오류:", error);
                showMessage("상대 팀 선수 데이터를 불러오는 데 실패했습니다.", 'error');
                hideLoading();
                return;
            } finally {
                hideLoading();
            }

            // Simple random lineup for opponent for now
            const oppPitcher = opponentPlayers.filter(p => p.position === '투수')[0] || opponentPlayers[0]; // Pick first pitcher or any player
            const oppLineup = opponentPlayers.filter(p => p.position !== '투수').slice(0, 9); // Pick first 9 non-pitchers

            if (!oppPitcher || oppLineup.length < 9) {
                showMessage(`상대 팀 (${opponentTeam.name})의 라인업을 구성할 수 없습니다.`, 'error');
                return;
            }

            console.log("경기 시작:", userTeam.name, "vs", opponentTeam.name);
            console.log("내 라인업:", batterLineup.map(p => p.name), "선발 투수:", startingPitcher.name);
            console.log("상대 라인업:", oppLineup.map(p => p.name), "상대 선발 투수:", oppPitcher.name);


            // Hide lineup setup, show game display
            document.getElementById('lineupSetup').classList.add('hidden');
            document.getElementById('gameDisplay').classList.remove('hidden');
            document.getElementById('nextInningBtn').classList.add('hidden'); // Hide next inning button initially

            await simulateGame(userTeam, userPlayers, startingPitcher, batterLineup, opponentTeam, opponentPlayers, oppPitcher, oppLineup);
        });

        async function simulateGame(teamA, teamAPlayers, teamAPitcher, teamALineup, teamB, teamBPlayers, teamBPitcher, teamBLineup, isAutoGame = false) {
            if (!isAutoGame) showLoading(); // Only show loading for manual games
            const gameLogDiv = document.getElementById('gameLog');
            gameLogDiv.innerHTML = ''; // Clear previous log

            document.getElementById('gameTeamA').textContent = teamA.name;
            document.getElementById('gameTeamB').textContent = teamB.name;
            document.getElementById('gameScoreA').textContent = '0';
            document.getElementById('gameScoreB').textContent = '0';

            let scoreA = 0;
            let scoreB = 0;
            let gameSummary = [];

            // Simulate 9 innings
            for (let inning = 1; inning <= 9; inning++) {
                gameSummary.push(`--- ${inning}회 ---`);
                gameLogDiv.scrollTop = gameLogDiv.scrollHeight; // Scroll to bottom

                // Team A's turn to bat against Team B's pitcher/defense
                const runsA = calculateInningRuns(teamALineup, teamBPitcher);
                scoreA += runsA;
                gameSummary.push(`${teamA.name} ${inning}회: ${runsA}점 득점. 총 ${scoreA}점.`);

                // Team B's turn to bat against Team A's pitcher/defense
                const runsB = calculateInningRuns(teamBLineup, teamAPitcher);
                scoreB += runsB;
                gameSummary.push(`${teamB.name} ${inning}회: ${runsB}점 득점. 총 ${scoreB}점.`);

                document.getElementById('gameScoreA').textContent = scoreA;
                document.getElementById('gameScoreB').textContent = scoreB;

                gameLogDiv.innerHTML = gameSummary.join('<br>');
                if (!isAutoGame) await new Promise(resolve => setTimeout(resolve, 500)); // Pause for effect in manual games
            }

            // Handle extra innings if tied after 9
            let currentInning = 9;
            while (scoreA === scoreB && currentInning < 12) { // Max 12 innings
                currentInning++;
                gameSummary.push(`--- 연장 ${currentInning}회 ---`);
                gameLogDiv.scrollTop = gameLogDiv.scrollHeight;

                const runsA = calculateInningRuns(teamALineup, teamBPitcher);
                scoreA += runsA;
                gameSummary.push(`${teamA.name} ${currentInning}회: ${runsA}점 득점. 총 ${scoreA}점.`);

                const runsB = calculateInningRuns(teamBLineup, teamAPitcher);
                scoreB += runsB;
                gameSummary.push(`${teamB.name} ${currentInning}회: ${runsB}점 득점. 총 ${scoreB}점.`);

                document.getElementById('gameScoreA').textContent = scoreA;
                document.getElementById('gameScoreB').textContent = scoreB;

                gameLogDiv.innerHTML = gameSummary.join('<br>');
                if (!isAutoGame) await new Promise(resolve => setTimeout(resolve, 500));
            }

            let winnerId = null;
            let loserId = null;
            let winnerName = '';
            let loserName = '';
            let isTie = false;

            if (scoreA > scoreB) {
                winnerId = teamA.id;
                loserId = teamB.id;
                winnerName = teamA.name;
                loserName = teamB.name;
            } else if (scoreB > scoreA) {
                winnerId = teamB.id;
                loserId = teamA.id;
                winnerName = teamB.name;
                loserName = teamA.name;
            } else {
                isTie = true;
                gameSummary.push("경기가 무승부로 종료되었습니다.");
                if (!isAutoGame) showMessage("경기가 무승부로 종료되었습니다.", 'info');
            }

            gameSummary.push(`--- 경기 종료 ---`);
            if (!isTie) {
                gameSummary.push(`${winnerName} 승리! ${scoreA} : ${scoreB}`);
                if (!isAutoGame) showMessage(`${winnerName} 승리!`, 'success');
            } else {
                gameSummary.push(`최종 점수: ${scoreA} : ${scoreB} (무승부)`);
            }
            gameLogDiv.innerHTML = gameSummary.join('<br>');

            // Save game result and update standings
            if (!isTie) {
                await saveGameResult(teamA.id, teamB.id, scoreA, scoreB, winnerId, loserId, gameSummary.join('\n'));
            } else {
                await saveGameResult(teamA.id, teamB.id, scoreA, scoreB, null, null, gameSummary.join('\n'), true);
            }

            if (!isAutoGame) {
                hideLoading();
                document.getElementById('lineupSetup').classList.remove('hidden'); // Show lineup setup again
                document.getElementById('gameDisplay').classList.add('hidden'); // Hide game display
            }

            return { scoreA, scoreB, winnerId, loserId, isTie, summary: gameSummary.join('\n') };
        }

        // More realistic run calculation based on player stats
        function calculateInningRuns(battingLineup, opposingPitcher) {
            let runs = 0;
            let outs = 0;
            let bases = [false, false, false]; // 1st, 2nd, 3rd
            let currentBatterIndex = 0;

            while (outs < 3) {
                const batter = battingLineup[currentBatterIndex % battingLineup.length];
                currentBatterIndex++;

                const hitChance = parseFloat(batter.battingAvg) * 2.5; // Scale batting average to hit chance
                const powerFactor = batter.power / 100; // Power 0-1
                const pitcherEffect = opposingPitcher.pitching / 100; // Pitching 0-1

                const randomRoll = Math.random();

                if (randomRoll < (hitChance * (1 - pitcherEffect * 0.3))) { // Hit!
                    let hitType = 'single';
                    if (randomRoll < (hitChance * powerFactor * 0.5)) { // Chance for extra base hits
                        if (randomRoll < (hitChance * powerFactor * 0.2)) {
                            hitType = 'homeRun';
                        } else if (randomRoll < (hitChance * powerFactor * 0.3)) {
                            hitType = 'triple';
                        } else {
                            hitType = 'double';
                        }
                    }

                    // Move runners
                    if (hitType === 'homeRun') {
                        runs += (bases[0] ? 1 : 0) + (bases[1] ? 1 : 0) + (bases[2] ? 1 : 0) + 1; // All runners + batter score
                        bases = [false, false, false];
                    } else if (hitType === 'triple') {
                        runs += (bases[0] ? 1 : 0) + (bases[1] ? 1 : 0) + (bases[2] ? 1 : 0);
                        bases = [false, false, true];
                    } else if (hitType === 'double') {
                        runs += (bases[2] ? 1 : 0); // 3rd base runner scores
                        bases = [false, (bases[0] ? true : false), (bases[1] ? true : false)]; // 1st to 2nd, 2nd to 3rd
                        bases[0] = false; // Batter is on 2nd
                        bases[1] = true;
                    } else { // Single
                        runs += (bases[2] ? 1 : 0); // 3rd base runner scores
                        bases = [(bases[0] ? true : false), (bases[1] ? true : false), (bases[2] ? true : false)]; // Move all runners one base
                        bases[0] = true; // Batter is on 1st
                    }
                } else { // Out!
                    outs++;
                }
            }
            return runs;
        }


        async function saveGameResult(teamAId, teamBId, scoreA, scoreB, winnerId, loserId, summaryText, isTie = false) {
            showLoading();
            try {
                const gameResult = {
                    teamA: teamAId,
                    teamB: teamBId,
                    scoreA: scoreA,
                    scoreB: scoreB,
                    winner: winnerId,
                    loser: loserId,
                    isTie: isTie,
                    summary: summaryText,
                    timestamp: new Date().toISOString() // Store as ISO string
                };

                // Save to public games collection
                const gamesCollectionRef = collection(db, `artifacts/${appId}/public/data/games`);
                await addDoc(gamesCollectionRef, gameResult);

                // Update standings for both teams
                if (!isTie) {
                    await updateTeamStandings(winnerId, true);
                    await updateTeamStandings(loserId, false);
                }
                // For ties, no change in wins/losses for now. Could add a 'ties' stat later.

                showMessage('경기 결과가 성공적으로 저장되었습니다!', 'success');
            } catch (error) {
                console.error("경기 결과 저장 오류:", error);
                showMessage(`경기 결과 저장 실패: ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }

        async function updateTeamStandings(teamId, isWinner) {
            const teamDocRef = doc(db, `artifacts/${appId}/public/data/teams`, teamId);
            const teamSnap = await getDoc(teamDocRef);

            if (teamSnap.exists()) {
                const currentData = teamSnap.data();
                const updatedData = {
                    wins: currentData.wins + (isWinner ? 1 : 0),
                    losses: currentData.losses + (isWinner ? 0 : 1)
                };
                await updateDoc(teamDocRef, updatedData);
                console.log(`팀 ${teamId} 스탠딩 업데이트: 승 ${updatedData.wins}, 패 ${updatedData.losses}`);
            } else {
                console.warn(`팀 ${teamId}을(를) 찾을 수 없습니다. 스탠딩 업데이트 불가.`);
            }
        }

        // --- Advanced Features (Season Management) ---
        document.getElementById('toggleAutoSeasonBtn').addEventListener('click', () => {
            if (leagueState.isSeasonActive) {
                clearInterval(autoSeasonInterval);
                leagueState.isSeasonActive = false;
                updateDoc(doc(db, `artifacts/${appId}/public/data/league_state`, 'current'), { isSeasonActive: false });
                showMessage('자동 시즌이 중지되었습니다.', 'info');
            } else {
                if (leagueTeams.length < MIN_TEAMS_FOR_LEAGUE) {
                    showMessage(`자동 시즌을 시작하려면 최소 ${MIN_TEAMS_FOR_LEAGUE}개 이상의 팀이 필요합니다. 현재 ${leagueTeams.length}팀.`, 'error');
                    return;
                }
                if (leagueState.seasonPhase === 'offseason' && leagueState.currentDay === 0) {
                    showModal('새 시즌을 시작하시겠습니까? 기존 기록은 초기화됩니다.', 'confirm', async () => {
                        await initializeSeason();
                        startAutoSeasonInterval();
                    });
                } else {
                    startAutoSeasonInterval();
                }
            }
        });

        document.getElementById('startNewSeasonBtn').addEventListener('click', () => {
            showModal('새 시즌을 시작하시겠습니까? 기존 기록은 초기화됩니다.', 'confirm', async () => {
                await initializeSeason();
                startAutoSeasonInterval();
            });
        });

        function startAutoSeasonInterval() {
            if (autoSeasonInterval) clearInterval(autoSeasonInterval); // Clear any existing interval
            autoSeasonInterval = setInterval(runAutoGame, 10000); // Every 10 seconds
            leagueState.isSeasonActive = true;
            updateDoc(doc(db, `artifacts/${appId}/public/data/league_state`, 'current'), { isSeasonActive: true });
            showMessage('자동 시즌이 시작되었습니다 (10초마다 경기).', 'info');
        }

        async function initializeSeason() {
            showLoading();
            try {
                // Reset all team records
                const teamUpdates = leagueTeams.map(team => {
                    const teamDocRef = doc(db, `artifacts/${appId}/public/data/teams`, team.id);
                    return updateDoc(teamDocRef, { wins: 0, losses: 0 });
                });
                await Promise.all(teamUpdates);

                // Clear existing schedule and games (optional, but good for clean season reset)
                const scheduleCollectionRef = collection(db, `artifacts/${appId}/public/data/schedule`);
                const existingSchedule = await getDocs(scheduleCollectionRef);
                const deleteSchedulePromises = existingSchedule.docs.map(docSnap => deleteDoc(doc(db, `artifacts/${appId}/public/data/schedule`, docSnap.id)));
                await Promise.all(deleteSchedulePromises);

                const gamesCollectionRef = collection(db, `artifacts/${appId}/public/data/games`);
                const existingGames = await getDocs(gamesCollectionRef);
                const deleteGamesPromises = existingGames.docs.map(docSnap => deleteDoc(doc(db, `artifacts/${appId}/public/data/games`, docSnap.id)));
                await Promise.all(deleteGamesPromises);


                // Generate new regular season schedule
                await generateRegularSeasonSchedule();

                // Set initial league state
                const leagueStateDocRef = doc(db, `artifacts/${appId}/public/data/league_state`, 'current');
                await setDoc(leagueStateDocRef, {
                    currentDay: 1,
                    seasonPhase: 'regular_season',
                    isSeasonActive: true,
                    lastGameRunTimestamp: new Date().toISOString(),
                    playoffBracket: null // Reset playoff bracket
                });
                leagueState = { currentDay: 1, seasonPhase: 'regular_season', isSeasonActive: true, lastGameRunTimestamp: new Date().toISOString(), playoffBracket: null };

                showMessage('새 시즌이 성공적으로 시작되었습니다!', 'success');
            } catch (error) {
                console.error("시즌 초기화 오류:", error);
                showMessage(`시즌 초기화 실패: ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }

        async function generateRegularSeasonSchedule() {
            const teamIds = leagueTeams.map(team => team.id);
            const numTeams = teamIds.length;
            if (numTeams < 2) return; // Not enough teams

            // Simple round-robin schedule generation
            // Each team plays every other team X times.
            // For 10 teams, if each plays every other team once, that's 9 games per team.
            // A full round-robin (each team plays every other team twice, home and away) is 2 * (numTeams - 1) games per team.
            // For 10 teams, 2 * 9 = 18 games per team.
            // To fill 70 days, we need more games. Let's aim for each team playing each other 7 times.
            // Total games per team: 9 * 7 = 63 games.
            // Total games in league: (numTeams * (numTeams - 1) / 2) * 7 = (10 * 9 / 2) * 7 = 45 * 7 = 315 games.
            // This means roughly 315 / 70 = ~4.5 games per day.

            const gamesPerMatchup = 7; // Each team plays every other team 7 times
            const allGames = [];

            for (let i = 0; i < numTeams; i++) {
                for (let j = i + 1; j < numTeams; j++) {
                    const teamAId = teamIds[i];
                    const teamBId = teamIds[j];
                    for (let k = 0; k < gamesPerMatchup; k++) {
                        // Alternate home/away
                        if (k % 2 === 0) {
                            allGames.push({ homeTeamId: teamAId, awayTeamId: teamBId });
                        } else {
                            allGames.push({ homeTeamId: teamBId, awayTeamId: teamAId });
                        }
                    }
                }
            }

            // Shuffle games to randomize schedule
            for (let i = allGames.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allGames[i], allGames[j]] = [allGames[j], allGames[i]];
            }

            const gamesPerDay = Math.ceil(allGames.length / REGULAR_SEASON_DAYS);
            let gameIndex = 0;

            const scheduleBatch = [];
            for (let day = 1; day <= REGULAR_SEASON_DAYS; day++) {
                const dailyGames = [];
                for (let i = 0; i < gamesPerDay && gameIndex < allGames.length; i++) {
                    dailyGames.push(allGames[gameIndex]);
                    gameIndex++;
                }
                if (dailyGames.length > 0) {
                    scheduleBatch.push(setDoc(doc(db, `artifacts/${appId}/public/data/schedule`, `day_${day}`), { games: dailyGames }));
                }
            }
            await Promise.all(scheduleBatch);
            console.log(`정규 시즌 ${allGames.length} 경기, ${REGULAR_SEASON_DAYS}일 동안 스케줄 생성 완료.`);
        }

        async function runAutoGame() {
            if (!leagueState.isSeasonActive) {
                console.log("자동 시즌이 비활성화되어 있습니다.");
                clearInterval(autoSeasonInterval);
                return;
            }
            if (!currentUserId) {
                console.warn("자동 시즌: 사용자 로그인 필요.");
                return;
            }

            const currentDay = leagueState.currentDay;
            const seasonPhase = leagueState.seasonPhase;

            console.log(`자동 경기 실행: ${seasonPhase}, ${currentDay}일차`);

            if (seasonPhase === 'regular_season') {
                if (currentDay > REGULAR_SEASON_DAYS) {
                    console.log("정규 시즌 종료. 플레이오프 준비.");
                    await startPlayoffs();
                    return;
                }

                const scheduleDocRef = doc(db, `artifacts/${appId}/public/data/schedule`, `day_${currentDay}`);
                const scheduleSnap = await getDoc(scheduleDocRef);

                if (scheduleSnap.exists()) {
                    const dailyGames = scheduleSnap.data().games;
                    console.log(`${currentDay}일차에 ${dailyGames.length}경기 진행.`);

                    for (const game of dailyGames) {
                        const teamA = leagueTeams.find(t => t.id === game.homeTeamId);
                        const teamB = leagueTeams.find(t => t.id === game.awayTeamId);

                        if (!teamA || !teamB) {
                            console.warn(`스케줄된 팀을 찾을 수 없습니다: ${game.homeTeamId} 또는 ${game.awayTeamId}`);
                            continue;
                        }

                        // Fetch players for both teams
                        let teamAPlayers = [];
                        let teamBPlayers = [];
                        try {
                            const teamA_players_snap = await getDocs(collection(db, `artifacts/${appId}/users/${teamA.ownerId}/my_players`));
                            teamAPlayers = teamA_players_snap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                            const teamB_players_snap = await getDocs(collection(db, `artifacts/${appId}/users/${teamB.ownerId}/my_players`));
                            teamBPlayers = teamB_players_snap.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                            if (teamAPlayers.length < 9 || teamBPlayers.length < 9) {
                                console.warn(`자동 경기: 팀 ${teamA.name} 또는 ${teamB.name}의 선수 데이터가 부족합니다. 스킵.`);
                                continue;
                            }

                            // Simple lineup selection for auto-games: first pitcher, first 9 non-pitchers
                            const teamAPitcher = teamAPlayers.filter(p => p.position === '투수')[0] || teamAPlayers[0];
                            const teamALineup = teamAPlayers.filter(p => p.position !== '투수').slice(0, 9);
                            const teamBPitcher = teamBPlayers.filter(p => p.position === '투수')[0] || teamBPlayers[0];
                            const teamBLineup = teamBPlayers.filter(p => p.position !== '투수').slice(0, 9);

                            if (!teamAPitcher || teamALineup.length < 9 || !teamBPitcher || teamBLineup.length < 9) {
                                console.warn(`자동 경기: 팀 ${teamA.name} 또는 ${teamB.name}의 라인업 구성 불가. 스킵.`);
                                continue;
                            }

                            console.log(`자동 경기 진행: ${teamA.name} vs ${teamB.name}`);
                            await simulateGame(teamA, teamAPlayers, teamAPitcher, teamALineup, teamB, teamBPlayers, teamBPitcher, teamBLineup, true);
                        } catch (playerFetchError) {
                            console.error(`자동 경기 중 선수 데이터 로드 오류 (${teamA.name} vs ${teamB.name}):`, playerFetchError);
                            continue;
                        }
                    }
                } else {
                    console.warn(`${currentDay}일차 스케줄을 찾을 수 없습니다.`);
                }

                // Advance to next day
                await updateDoc(doc(db, `artifacts/${appId}/public/data/league_state`, 'current'), {
                    currentDay: currentDay + 1,
                    lastGameRunTimestamp: new Date().toISOString()
                });
                leagueState.currentDay = currentDay + 1; // Update local state immediately
                updateSeasonStatusDisplay();

            } else if (seasonPhase === 'playoffs') {
                // Playoff simulation logic (simplified for now)
                if (currentDay > TOTAL_SEASON_DAYS) {
                    console.log("플레이오프 종료. 시즌 종료.");
                    await endSeason();
                    return;
                }

                // Example: Simulate one playoff game per day if a bracket exists
                const playoffBracket = leagueState.playoffBracket;
                if (playoffBracket && playoffBracket.currentRoundGames && playoffBracket.currentRoundGames.length > 0) {
                    const gameToSimulate = playoffBracket.currentRoundGames[0]; // Just simulate the first game for simplicity
                    const teamA = leagueTeams.find(t => t.id === gameToSimulate.teamAId);
                    const teamB = leagueTeams.find(t => t.id === gameToSimulate.teamBId);

                    if (teamA && teamB) {
                        let teamAPlayers = [];
                        let teamBPlayers = [];
                        try {
                            const teamA_players_snap = await getDocs(collection(db, `artifacts/${appId}/users/${teamA.ownerId}/my_players`));
                            teamAPlayers = teamA_players_snap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                            const teamB_players_snap = await getDocs(collection(db, `artifacts/${appId}/users/${teamB.ownerId}/my_players`));
                            teamBPlayers = teamB_players_snap.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                            if (teamAPlayers.length < 9 || teamBPlayers.length < 9) {
                                console.warn(`자동 경기: 팀 ${teamA.name} 또는 ${teamB.name}의 선수 데이터가 부족합니다. 스킵.`);
                                return;
                            }

                            const teamAPitcher = teamAPlayers.filter(p => p.position === '투수')[0] || teamAPlayers[0];
                            const teamALineup = teamAPlayers.filter(p => p.position !== '투수').slice(0, 9);
                            const teamBPitcher = teamBPlayers.filter(p => p.position === '투수')[0] || teamBPlayers[0];
                            const teamBLineup = teamBPlayers.filter(p => p.position !== '투수').slice(0, 9);

                            if (!teamAPitcher || teamALineup.length < 9 || !teamBPitcher || teamBLineup.length < 9) {
                                console.warn(`자동 경기: 팀 ${teamA.name} 또는 ${teamB.name}의 라인업 구성 불가. 스킵.`);
                                return;
                            }

                            const result = await simulateGame(teamA, teamAPlayers, teamAPitcher, teamALineup, teamB, teamBPlayers, teamBPitcher, teamBLineup, true);

                            // Update playoff bracket with winner/loser
                            const updatedBracketGames = playoffBracket.currentRoundGames.filter(g => !(g.teamAId === gameToSimulate.teamAId && g.teamBId === gameToSimulate.teamBId));
                            if (!result.isTie) {
                                updatedBracketGames.push({ winnerId: result.winnerId, loserId: result.loserId, round: playoffBracket.currentRound });
                            }
                            playoffBracket.currentRoundGames = updatedBracketGames; // Update remaining games

                            // Advance playoff round if all games in current round are done
                            if (playoffBracket.currentRoundGames.length === 0) {
                                console.log(`플레이오프 ${playoffBracket.currentRound} 라운드 종료.`);
                                // Logic to determine next round matchups and advance round
                                playoffBracket.currentRound++;
                                if (playoffBracket.currentRound > 3) { // Assuming 3 rounds for simplicity (e.g., Semis, Finals)
                                    console.log("플레이오프 최종 우승팀 결정!");
                                    await endSeason();
                                    return;
                                }
                                // Generate next round games based on winners
                                playoffBracket.currentRoundGames = generateNextPlayoffRound(playoffBracket.currentRound, playoffBracket.winners); // Need to store winners from previous round
                            }
                            await updateDoc(doc(db, `artifacts/${appId}/public/data/league_state`, 'current'), { playoffBracket: playoffBracket });

                        } catch (playerFetchError) {
                            console.error(`자동 경기 중 선수 데이터 로드 오류 (${teamA.name} vs ${teamB.name}):`, playerFetchError);
                        }
                    } else {
                        console.warn("플레이오프 게임 팀을 찾을 수 없습니다.");
                    }
                } else {
                    console.log("플레이오프 게임이 없습니다. 다음 라운드 준비 또는 시즌 종료.");
                    if (!playoffBracket || !playoffBracket.currentRoundGames || playoffBracket.currentRoundGames.length === 0) {
                         await endSeason(); // If no more games, end season
                         return;
                    }
                }

                // Advance to next day
                await updateDoc(doc(db, `artifacts/${appId}/public/data/league_state`, 'current'), {
                    currentDay: currentDay + 1,
                    lastGameRunTimestamp: new Date().toISOString()
                });
                leagueState.currentDay = currentDay + 1;
                updateSeasonStatusDisplay();
            }
        }

        async function startPlayoffs() {
            showLoading();
            try {
                // Determine playoff teams (e.g., top 4 teams)
                const sortedTeams = [...leagueTeams].sort((a, b) => {
                    const winPctA = a.wins / (a.wins + a.losses) || 0;
                    const winPctB = b.wins / (b.wins + b.losses) || 0;
                    return winPctB - winPctA;
                });
                const playoffTeams = sortedTeams.slice(0, Math.min(4, sortedTeams.length)); // Top 4 teams

                if (playoffTeams.length < 2) {
                    showMessage('플레이오프를 시작할 팀이 부족합니다.', 'error');
                    await endSeason(); // End season if not enough teams for playoffs
                    return;
                }

                // Generate initial playoff bracket (e.g., Semifinals)
                let playoffBracket = {
                    currentRound: 1,
                    currentRoundGames: [], // Games for the current round
                    winners: [] // Winners of previous rounds
                };

                // Simple 4-team bracket: #1 vs #4, #2 vs #3
                if (playoffTeams.length >= 4) {
                    playoffBracket.currentRoundGames.push({ teamAId: playoffTeams[0].id, teamBId: playoffTeams[3].id, matchup: `${playoffTeams[0].name} vs ${playoffTeams[3].name}` });
                    playoffBracket.currentRoundGames.push({ teamAId: playoffTeams[1].id, teamBId: playoffTeams[2].id, matchup: `${playoffTeams[1].name} vs ${playoffTeams[2].name}` });
                } else if (playoffTeams.length === 2) {
                    // If only 2 teams, they play finals directly
                    playoffBracket.currentRoundGames.push({ teamAId: playoffTeams[0].id, teamBId: playoffTeams[1].id, matchup: `${playoffTeams[0].name} vs ${playoffTeams[1].name}` });
                } else {
                    showMessage('플레이오프를 위한 충분한 팀이 없습니다.', 'error');
                    await endSeason();
                    return;
                }


                await updateDoc(doc(db, `artifacts/${appId}/public/data/league_state`, 'current'), {
                    seasonPhase: 'playoffs',
                    currentDay: REGULAR_SEASON_DAYS + 1,
                    playoffBracket: playoffBracket,
                    isSeasonActive: true // Keep active for playoffs
                });
                leagueState.seasonPhase = 'playoffs';
                leagueState.currentDay = REGULAR_SEASON_DAYS + 1;
                leagueState.playoffBracket = playoffBracket;
                leagueState.isSeasonActive = true;
                updateSeasonStatusDisplay();
                showMessage('플레이오프가 시작되었습니다!', 'info');
                startAutoSeasonInterval(); // Ensure auto-season continues for playoffs
            } catch (error) {
                console.error("플레이오프 시작 오류:", error);
                showMessage(`플레이오프 시작 실패: ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }

        // Placeholder for generating next playoff round (needs to be implemented fully)
        function generateNextPlayoffRound(round, previousWinners) {
            // This would take the winners from the previous round and pair them up for the next.
            // For a simple 4-team bracket, round 1 has 2 games, winners play in round 2 (final).
            // Example: previousWinners = [winner1, winner2]
            // return [{ teamAId: winner1.id, teamBId: winner2.id, matchup: "Finals" }];
            console.log(`플레이오프 다음 라운드 ${round} 생성 (미구현)`);
            return []; // Return empty for now, needs actual logic
        }

        async function endSeason() {
            showLoading();
            try {
                clearInterval(autoSeasonInterval);
                await updateDoc(doc(db, `artifacts/${appId}/public/data/league_state`, 'current'), {
                    seasonPhase: 'offseason',
                    isSeasonActive: false,
                    currentDay: 0, // Reset day for new season
                    playoffBracket: null // Clear bracket
                });
                leagueState.seasonPhase = 'offseason';
                leagueState.isSeasonActive = false;
                leagueState.currentDay = 0;
                leagueState.playoffBracket = null;
                updateSeasonStatusDisplay();
                updateAutoSeasonButton();
                showMessage('시즌이 종료되었습니다!', 'info');
            } catch (error) {
                console.error("시즌 종료 오류:", error);
                showMessage(`시즌 종료 실패: ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }

        // --- Initial Load ---
        window.onload = initialSignIn; // Start the authentication process on window load.
    </script>
</body>
</html>
